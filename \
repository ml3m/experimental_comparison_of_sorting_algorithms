##############################################
# 				                    	     #
#    Experimental Comparison                 #
#               of Sorting Algorithms        #
#              				                 #
# 		        github.com/ml3m		         #
# 					                         #
##############################################

from PySortAlgos import (BubbleSort,
                         SelectionSort,
                         InsertSort,
                         QuickSort,
                         MergeSort,
                         HeapSort,
                         RadixSort,
                         SmoothSort,
                         Timsort,
                         CombSort,
                         isSorted)

import time
import random

TEST_E = 30  # ~ 1bil only for test puposes
START_E = 3  # 2^2 = 4
MAX_E = 10  # 2^22 = 4.194.304
TRIES = 1  # default will be 1, maybe a better implementation for final paper
TOTEST = (
    # (algorithm(class),  Name,       Limit)
    (BubbleSort,    "BubbleSort",    10),
    (SelectionSort, "SelectionSort", 10),
    (InsertSort,    "InsertSort",    10),
    (HeapSort,      "HeapSort",      10),
    (MergeSort,     "MergeSort",     10),
    (QuickSort,     "QuickSort",     10),
    (RadixSort,     "RadixSort",     10),
    (SmoothSort,    "SmoothSort",    10),
    (Timsort,       "Timsort",       10),
    (CombSort,      "CombSort",      10)
)

# printing of the top categories
# nameList = ""
# for r in TOTEST:
#    nameList += ("\t\t" if len(nameList) > 0 else "") + r[1]
nameList = "\t\t".join(r[1] for r in TOTEST)

print("Elements\t\t" + nameList)
# main

def quickselect(arr, k):
    if len(arr) == 1:
        return arr[0]
    pivot = random.choice(arr)
    lows = [x for x in arr if x < pivot]
    highs = [x for x in arr if x > pivot]
    pivots = [x for x in arr if x == pivot]

    if k < len(lows):
        return quickselect(lows, k)
    elif k < len(lows) + len(pivots):
        return pivots[0]
    else:
        return quickselect(highs, k - len(lows) - len(pivots))

list_kind = 1
print_ok1 = False
print_ok2 = False
print_ok3 = False

# process until limit MAX_E is reached.
while list_kind <= 4:
    e = START_E
    while e <= MAX_E:
        res = []
        max = -1
        # for each sorting algorithm we take
        for algorithm, name, limit in TOTEST:
            if e > limit:
                res.append(None)
            else:
                sum = 0
                for _ in range(TRIES):
                    # create a list with 2^e Elements
                    
                    if list_kind == 1:
                        # Shuffled
                        
                        if print_ok1 is False:
                            print("\n\n\tShuffled\n\n")
                            print_ok1 = True

                        list_to_sort = list(range(0, 2**e))
                        random.shuffle(list_to_sort)
                    elif list_kind == 2:
                        # Almost Sorted

                        if print_ok2 is False:
                            print("\n\n\tAlmost Sorted\n\n")
                            print_ok2 = True

                        list_to_sort = list(range(0, 2**e))
                        random.shuffle(list_to_sort)
                        while True:
                            choice1 = random.choice(list_to_sort)
                            choice2 = random.choice(list_to_sort)
                            if choice1 != choice2:
                                break

                        aux = list_to_sort[choice1]
                        list_to_sort[choice1] = list_to_sort[choice2]
                        list_to_sort[choice1] = aux
                    elif list_to_sort == 3:
                        # reversed Sorted

                        list_to_sort = list(range(0, 2**e))
                        list_to_sort = list_to_sort[::-1]
                    else:
                        # Already sorted

                        if print_ok3 is False:
                            print("\n\n\tSorted\n\n")
                            print_ok3 = True
                        list_to_sort = list(range(0, 2**e))
                    
                    # time started
                    t1 = time.time()
                    sortedlist = algorithm().sort(list_to_sort)
                    # sort by r[0] which is the class algorithm
                    # apply method .sort from that class to list_to_sort - list of values
    
                    sum += time.time() - t1     # sum = the times used for sum/ TRIES
                    # just to make sure
                    if not isSorted(sortedlist):
                        print("Error in " + name)
    
    # finds the avg of all tries and then display it bellow
    # if TRIES = 1 -> useless
                res.append(sum / TRIES)
                if res[-1] > max:
                    max = res[-1]
    
    # printing this happens after each 2^e and e+=1
    # prercentage calculation
        tp = "2^" + str(e) + " = " + str(2**e) + " \t\t"
        for v in res:
            if v is None:
                tp += " \t\t"
            else:
                p = "0"
                if max > 0:
                    p = str(round(100*v/max, 2))
                tp += str(round(v, 5)) + "s (" + p + "%)"
                if v == 0: tp += "   "
            tp += "    \t"
        print(tp)
        e += 1
    list_kind += 1



print("\nFinish :)")
